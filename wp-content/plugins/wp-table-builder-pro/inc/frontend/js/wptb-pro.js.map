{"version":3,"sources":["borders-manage-run.js","list-tooltip.js","sticky-row.js","styled-list-tooltip.js","styled-list.js","WPTB_BordersManage.js","WPTB_TableDirectives.js"],"names":["document","addEventListener","e","tables","querySelectorAll","responsiveFront","detail","i","length","WPTB_BordersManage","table","bordersInitialization","sortingTable","Array","from","map","t","classList","alignment","some","c","match","RegExp","exec","liElement","tooltip","querySelector","textElement","savedInnerHtml","innerHTML","concat","textPosObj","getBoundingClientRect","liPosObject","textElementRelativePosObj","Math","abs","x","y","calculatedPos","left","top","offsetHeight","height","posXAxisLeft","offsetWidth","posXAxisRight","width","multiplier","posYAxisTop","posYAxisBottom","setAttribute","calculateTooltipPosition","forEach","stickyRow","stickyHeight","tableTop","tableEnd","firstRow","getAttribute","tablePosition","scrollPosition","window","pageYOffset","bottom","style","maxWidth","col","getComputedStyle","getPropertyValue","scroll","add","remove","li","position","tooltipTipPad","target","p","newStyle","replace","options","arguments","undefined","this","WPTB_RecalculateIndexes","thisObject","itemsPerHeader","tableMaxCols","maxCols","cellsStylesScheme","tableDirectives","WPTB_TableDirectives","typeFirst","typeSecond","borderRadiusVal","switchMode","getDirective","_typeof","WPTB_GetDirectionAfterReconstruction","hasOwnProperty","switchModeObj","tableOld","newTable","switchBorderOnlyColumnRow","type","borderRadiusesSet","spaceBorderSpacingExchange","call","value","parseInt","tds","_toConsumableArray","setDirective","td","borderRadius","borderTopLeftRadius","borderBottomLeftRadius","borderTopRightRadius","borderBottomRightRadius","rowsLength","rows","dataYIndexStart","_this","borderWidth","innerBordersSet","tableRows","columnCount","firstRowTdLast","firstRowTds","children","dataset","xIndex","colSpan","row","previousSibling","borderRightWidth","nextSibling","borderLeftWidth","_ret","rowsCount","v","rowSpan","borderBottomWidth","tdsBetween","tdsBottom","tdsRow","borderTopWidth","getElementsByTagName","typeNumber","borderSpacing","split","reverse","join","rowBgColorReplaceToCellBgColor","color","trs","tr","wptbBgColor","backgroundColor","changeRowBgColor","tblRow","selector","bgColor","wptbRowBgColor","orgColor","changeColumnBgColor","index","wptbColumnBgColor","wptbOwnBgColor","tableDirectivesDataKey","getDirectives","encodedTableDirectives","JSON","parse","atob","saveDirectives","btoa","stringify","way","field"],"mappings":"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","file":"wptb-pro.js","sourcesContent":["\ndocument.addEventListener('responsive:front', function (e){\n    function sortingTable(e) {\n        const tables = document.querySelectorAll('.wptb-preview-table');\n        const responsiveFront = e.detail.responsiveFront;\n        for (let i = 0; i < tables.length; i++) {\n            const bordersManage = new WPTB_BordersManage({ table: tables[i] });\n            bordersManage.bordersInitialization(responsiveFront);\n        }\n    }\n    sortingTable(e);\n}, false)\n\n","document.addEventListener('DOMContentLoaded', function () {\n\n    /**\n     * Add realtime tooltip position recalculation support for list elements.\n     *\n     * There are so many factors that will affect the layout of table. Because of this, dynamically calculation the tooltip position will yield better results.\n     */\n    function listToolTipSupport() {\n        const tooltipElements = Array.from(document.querySelectorAll('.wptb-list-container .wptb-tooltip'));\n\n        tooltipElements.map(t => {\n            const classList = Array.from(t.classList);\n\n            let alignment = 'top';\n\n            // get alignment of list tooltip element\n            classList.some(c => {\n                const regex = new RegExp(/^wptb-tooltip-(.+)$/g);\n                const match = regex.exec(c);\n\n                if (match !== null) {\n                    alignment = match[1];\n                    return true;\n                }\n                return false;\n            });\n\n            // bind calculation to mouseenter event\n            t.addEventListener('mouseenter', () => {\n                calculateTooltipPosition(t,alignment);\n            })\n        });\n\n        /**\n         * Calculate tooltip position of list element.\n         *\n         * @param {HTMLElement} liElement list element\n         * @param {string} alignment alignment type, possible values are top, right, bottom, left\n         */\n        function calculateTooltipPosition(liElement, alignment) {\n            const tooltip = liElement.querySelector('.tooltip');\n            const textElement = liElement.querySelector('p');\n\n            // tip padding value\n            const tooltipTipPad = 10;\n\n            // save html content of text element for future restore\n            const savedInnerHtml = textElement.innerHTML;\n\n            // wrapping text content of p element with a span value to calculate the correct size for its text content\n            textElement.innerHTML = `<span id=\"sizeCalculator\">${savedInnerHtml}</span>`;\n\n            const textPosObj = textElement.querySelector('#sizeCalculator').getBoundingClientRect();\n            const liPosObject = liElement.getBoundingClientRect();\n\n            // calculate the position of text element relative to list element\n            const textElementRelativePosObj = {\n                left: Math.abs(liPosObject.x - textPosObj.x),\n                top: Math.abs(liPosObject.y - textPosObj.y)\n            }\n\n            // position object for final tooltip element position\n            const calculatedPos = {\n                left: 0,\n                top: 0,\n            }\n\n            // calculate for position left and right\n            if (alignment === 'left' || alignment === 'right') {\n                calculatedPos.top = textElementRelativePosObj.top - (tooltip.offsetHeight / 2) + (textPosObj.height / 2);\n\n                // position left multiplier\n                const posXAxisLeft = -(tooltip.offsetWidth + tooltipTipPad);\n\n                // position right multiplier\n                const posXAxisRight = textPosObj.width + tooltipTipPad;\n\n                const multiplier = alignment === 'left' ? posXAxisLeft : posXAxisRight;\n                calculatedPos.left = textElementRelativePosObj.left + multiplier;\n            } else {\n                calculatedPos.left = textElementRelativePosObj.left + (textPosObj.width / 2) - (tooltip.offsetWidth / 2);\n\n                // position top multiplier\n                const posYAxisTop = -(tooltip.offsetHeight + tooltipTipPad);\n\n                // position bottom multiplier\n                const posYAxisBottom = textPosObj.height + tooltipTipPad;\n\n                const multiplier = alignment === 'top' ? posYAxisTop : posYAxisBottom;\n                calculatedPos.top = textElementRelativePosObj.top + multiplier;\n            }\n\n            textElement.innerHTML = savedInnerHtml;\n\n            tooltip.setAttribute('style', `left: ${calculatedPos.left}px; top: ${calculatedPos.top}px`);\n        }\n    }\n\n    listToolTipSupport();\n});\n\n","document.addEventListener('DOMContentLoaded', function() {\n    \n    function topRowSticky() {\n        const tables = document.querySelectorAll('.wptb-preview-table');\n        \n        if (tables.length > 0) {\n            tables.forEach(table => {\n                let firstRow = table.querySelector('tbody > tr:first-child');\n\n                let isStickyHeader = firstRow.getAttribute('data-wptb-sticky-row');\n                if (isStickyHeader == 'true') {\n                    tableStickyHeader(table, firstRow);\n                }\n            });\n        }\n        \n        \n        function tableStickyHeader(table, stickyRow) {\n            const tablePosition = table.getBoundingClientRect();\n            const stickyHeight = stickyRow.getBoundingClientRect().height;\n            const scrollPosition = window.pageYOffset;\n            const tableTop = tablePosition.top + scrollPosition;\n            const tableEnd = (tablePosition.bottom - stickyHeight) + scrollPosition;\n\n            stickyRow.style.maxWidth = tablePosition.width + 'px';\n\n            const columnsInRow = Array.from(stickyRow.querySelectorAll('td'));\n            columnsInRow.map(col => {\n                let style = window.getComputedStyle(col);\n                let width = style.getPropertyValue('width');\n                col.style.width = width;\n            });\n\n            // Add Scroll Event for Adding or Removing class\n            document.addEventListener('scroll', function() {\n                let scroll = window.pageYOffset;\n\n                if ( scroll > (tableTop + stickyHeight) && scroll < tableEnd) {\n                    stickyRow.classList.add('wptb-sticky-header');\n                } \n                \n                if ( scroll > tableEnd || scroll < tableTop ){\n                    stickyRow.classList.remove('wptb-sticky-header');\n                }\n            });\n        }\n    }\n\n    topRowSticky();\n});\n","document.addEventListener('DOMContentLoaded', function () {\n\n    /**\n     * Add realtime tooltip position recalculation support for list elements.\n     *\n     * There are so many factors that will affect the layout of table. Because of this, dynamically calculation the tooltip position will yield better results.\n     */\n    function styledListToolTipSupport() {\n        const tooltipElements = Array.from(document.querySelectorAll('.wptb-styled_list-container .wptb-tooltip'));\n\n        tooltipElements.map(t => {\n            const classList = Array.from(t.classList);\n\n            let alignment = 'top';\n\n            // get alignment of list tooltip element\n            classList.some(c => {\n                const regex = new RegExp(/^wptb-tooltip-(.+)$/g);\n                const match = regex.exec(c);\n\n                if (match !== null) {\n                    alignment = match[1];\n                    return true;\n                }\n                return false;\n            });\n\n            // bind calculation to mouseenter event\n            t.addEventListener('mouseenter', (e) => {\n                calculateTooltipPosition(e.target,alignment);\n            })\n        });\n\n        /**\n         * Calculate tooltip position of list element.\n         *\n         * @param {HTMLElement} liElement list element\n         * @param {string} alignment alignment type, possible values are top, right, bottom, left\n         */\n        function calculateTooltipPosition(li, position) {\n            const tooltip = li.querySelector('.tooltip');\n            const textElement = li.querySelector('p');\n\n            // tip padding value\n            const tooltipTipPad = 10;\n\n            // save html content of text element for future restore\n            const savedInnerHtml = textElement.innerHTML;\n\n            // wrapping text content of p element with a span value to calculate the correct size for its text content\n            textElement.innerHTML = `<span id=\"sizeCalculator\">${savedInnerHtml}</span>`;\n\n            const textPosObj = textElement.querySelector('#sizeCalculator').getBoundingClientRect();\n\n            const liPosObject = li.getBoundingClientRect();\n\n            // calculate the position of text element relative to list element\n            const textElementRelativePosObj = {\n                left: Math.abs(liPosObject.x - textPosObj.x),\n                top: Math.abs(liPosObject.y - textPosObj.y)\n            }\n\n            // position object for final tooltip element position\n            const calculatedPos = {\n                left: 0,\n                top: 0,\n            }\n\n            // calculate for position left and right\n            if (position === 'left' || position === 'right') {\n                calculatedPos.top = textElementRelativePosObj.top - (tooltip.offsetHeight / 2) + (textPosObj.height / 2) - (tooltipTipPad/2);\n\n                // position left multiplier\n                const posXAxisLeft = -(tooltip.offsetWidth + tooltipTipPad);\n\n                // position right multiplier\n                const posXAxisRight = textPosObj.width + tooltipTipPad;\n\n                const multiplier = position === 'left' ? posXAxisLeft : posXAxisRight;\n                calculatedPos.left = textElementRelativePosObj.left + multiplier;\n            } else {\n                calculatedPos.left = textElementRelativePosObj.left + (textPosObj.width / 2) - (tooltip.offsetWidth / 2);\n\n                // position top multiplier\n                const posYAxisTop = -(tooltip.offsetHeight + tooltipTipPad);\n\n                // position bottom multiplier\n                const posYAxisBottom = textPosObj.height + tooltipTipPad;\n\n                const multiplier = position === 'top' ? posYAxisTop : posYAxisBottom;\n                calculatedPos.top = textElementRelativePosObj.top + multiplier;\n            }\n\n            textElement.innerHTML = savedInnerHtml;\n\n            tooltip.setAttribute('style', `left: ${calculatedPos.left}px; top: ${calculatedPos.top}px`);\n        }\n    }\n\n    styledListToolTipSupport();\n});\n\n","/**\n * Styled list element related frontend js scripts.\n */\ndocument.addEventListener('DOMContentLoaded', () => {\n    /**\n     * Fix for vertical spacing between icon and text components of styled list element being overridden by both plugin and theme styles.\n     */\n    function marginFix() {\n        const listP = Array.from(document.querySelectorAll('.wptb-styled_list-container li p'));\n\n        listP.map(p => {\n            const styleAttr = p.getAttribute('style');\n            const newStyle = styleAttr.replace(/margin-left: (\\d+)px/, '$& !important');\n            p.setAttribute('style', newStyle);\n        })\n    }\n\n    marginFix();\n})\n","var WPTB_BordersManage = function (options = {}) {\n    let table = options.table;\n    this.table = options.table;\n    WPTB_RecalculateIndexes(table);\n    const thisObject = this;\n    this.itemsPerHeader = 0;\n    this.tableMaxCols = table.maxCols;\n    this.cellsStylesScheme = {};\n\n    const tableDirectives = new WPTB_TableDirectives(table);\n\n    /**\n     * checks whether the table should be in the sort state\n     * and connects the necessary handlers\n     *\n     * @param {object} responsiveFront\n     */\n    this.bordersInitialization = function(responsiveFront) {\n        let typeFirst;\n        let typeSecond;\n        let borderRadiusVal;\n        if(tableDirectives.getDirective(['innerBorders', 'active']) === 'row') {\n            typeFirst = 'row';\n            typeSecond = 'column';\n        } else if(tableDirectives.getDirective(['innerBorders', 'active']) === 'column') {\n            typeFirst = 'column';\n            typeSecond = 'row';\n        }\n        if(tableDirectives.getDirective(['innerBorders', 'borderRadiuses']))\n            borderRadiusVal = tableDirectives.getDirective(['innerBorders', 'borderRadiuses', tableDirectives.getDirective(['innerBorders', 'active'])]);\n        if(!typeFirst || typeof typeFirst !== 'string' || !typeSecond || typeof typeSecond !== 'string') return;\n\n        let switchMode = WPTB_GetDirectionAfterReconstruction(this.table, typeFirst, typeSecond, 'column', responsiveFront);\n\n        if(typeof switchMode === 'object' && switchMode.hasOwnProperty('switch')) {\n            function borderRadiusesSetRun (e) {\n                let switchModeObj = switchMode.switch(e);\n                if(typeof switchModeObj === 'object') {\n                    this.itemsPerHeader = switchModeObj.itemsPerHeader;\n                    if(switchModeObj.hasOwnProperty('newTable')) {\n                        let tableOld = this.table;\n                        this.table = switchModeObj.newTable;\n                        this.switchBorderOnlyColumnRow(switchModeObj.type[0]);\n                        this.borderRadiusesSet(switchModeObj.type[0], borderRadiusVal);\n                        this.spaceBorderSpacingExchange(switchModeObj.type[1]);\n                        this.table = tableOld;\n                    } else {\n                        this.switchBorderOnlyColumnRow(switchModeObj.type[0]);\n                        this.borderRadiusesSet(switchModeObj.type[0], borderRadiusVal);\n                        this.spaceBorderSpacingExchange(switchModeObj.type[1]);\n                    }\n                }\n            }\n            //borderRadiusesSetRun.call(thisObject);\n            this.table.addEventListener(\n                'table:rebuilt',\n                function (e) {\n                    borderRadiusesSetRun.call(thisObject, e);\n                },\n                false\n            );\n        }\n    }\n\n    /**\n     * sets border Radiuses for necessary Cells\n     *\n     * @param {string} type\n     * @param {string} value\n     */\n    this.borderRadiusesSet = function (type, value) {\n        if(!parseInt(value, 10)){\n            value = null;\n        }\n        let tds = this.table.querySelectorAll('td');\n        tds = [...tds];\n        if(type === 'all') {\n            tableDirectives.setDirective(['innerBorders', 'borderRadiuses', 'all'], value);\n            if(value) {\n                value = value + 'px';\n            }\n            tds.map(td => {\n                td.style.borderRadius = value;\n            })\n        } else if(type === 'row') {\n            tableDirectives.setDirective(['innerBorders', 'borderRadiuses', 'row'], value);\n            tds.map(td => {\n                td.style.borderRadius = null;\n            })\n            if(value) {\n                let tds1 = this.table.querySelectorAll('tr td:first-child');\n                tds1 = [...tds1];\n                tds1.map(td => {\n                    td.style.borderTopLeftRadius = value + 'px';\n                    td.style.borderBottomLeftRadius = value + 'px';\n                })\n\n                let tds2 = this.table.querySelectorAll('tr td:last-child');\n                tds2 = [...tds2];\n                tds2.map(td => {\n                    td.style.borderTopRightRadius = value + 'px';\n                    td.style.borderBottomRightRadius = value + 'px';\n                })\n            }\n        } else if(type === 'column') {\n            tableDirectives.setDirective(['innerBorders', 'borderRadiuses', 'column'], value);\n            tds.map(td => {\n                td.style.borderRadius = null;\n            })\n            if(value) {\n                let rowsLength = this.table.rows.length;\n                let dataYIndexStart = 0;\n                while (rowsLength > 0) {\n                    let tdsTop = this.table.querySelectorAll(`[data-y-index=\"${dataYIndexStart}\"]`);\n                    tdsTop = [...tdsTop];\n                    tdsTop.map((td) => {\n                        td.style.borderTopLeftRadius = value + 'px';\n                        td.style.borderTopRightRadius = value + 'px';\n                    });\n\n                    let tdsBottom;\n                    if(this.itemsPerHeader && dataYIndexStart + this.itemsPerHeader < rowsLength && dataYIndexStart + 1 < rowsLength) {\n                        tdsBottom = this.table.querySelectorAll(`[data-y-index=\"${dataYIndexStart + this.itemsPerHeader}\"]`);\n                    } else {\n                        tdsBottom = this.table.querySelectorAll('tr:last-child td');\n                    }\n\n                    tdsBottom = [...tdsBottom];\n                    tdsBottom.map((td) => {\n                        td.style.borderBottomLeftRadius = value + 'px';\n                        td.style.borderBottomRightRadius = value + 'px';\n                    });\n\n                    if (this.itemsPerHeader) {\n                        rowsLength -= this.itemsPerHeader + 1;\n                        dataYIndexStart += this.itemsPerHeader + 1;\n                    } else {\n                        rowsLength = 0;\n                    }\n                }\n            }\n        }\n    };\n\n    this.switchBorderOnlyColumnRow = function (type) {\n        let borderWidth = tableDirectives.getDirective(['innerBorders', 'borderWidth']);\n        this.innerBordersSet(borderWidth);\n\n        if (type === 'row') {\n            let tableRows = this.table.rows;\n            let columnCount = 0;\n            if (tableRows.length > 0) {\n                let firstRow = tableRows[0];\n                let firstRowTds = firstRow.children;\n                firstRowTds = [...firstRowTds];\n                let firstRowTdLast = firstRowTds[firstRowTds.length - 1]\n                columnCount = parseInt(firstRowTdLast.dataset.xIndex) + firstRowTdLast.colSpan;\n            }\n\n            tableRows = [...tableRows];\n\n            tableRows.map(row => {\n                let tds = row.children;\n                tds = [...tds];\n                tds.map(td => {\n                    if(td.previousSibling === null) {\n                        if (td.colSpan < columnCount) {\n                            td.style.borderRightWidth = '0px';\n                        }\n                    } else if(td.nextSibling === null) {\n                        td.style.borderLeftWidth = '0px';\n                    } else {\n                        td.style.borderRightWidth = '0px';\n                        td.style.borderLeftWidth = '0px';\n                    }\n                });\n            });\n            tableDirectives.setDirective(['innerBorders', 'active'], 'row');\n        } else if (type === 'column') {\n            let tableRows = this.table.rows;\n            let rowsCount = tableRows.length;\n            if (rowsCount <= 1) return;\n\n            let rowsLength = this.table.rows.length;\n            let dataYIndexStart = 0;\n            while (rowsLength > 0) {\n                let tdsTop = this.table.querySelectorAll(`[data-y-index=\"${dataYIndexStart}\"]`);\n                tdsTop = [...tdsTop];\n                tdsTop.map((td) => {\n                    if (td.rowSpan < rowsCount) {\n                        td.style.borderBottomWidth = '0px';\n                    }\n                });\n\n                let tdsBetween = [];\n                let tdsBottom;\n                if(this.itemsPerHeader && dataYIndexStart + this.itemsPerHeader < rowsLength && dataYIndexStart + 1 < rowsLength) {\n                    for(let i = dataYIndexStart + 1; i < dataYIndexStart + this.itemsPerHeader; i++) {\n                        let tdsRow = this.table.querySelectorAll(`[data-y-index=\"${i}\"]`);\n                        tdsRow = [...tdsRow];\n                        tdsBetween = tdsBetween.concat(tdsRow);\n                    }\n\n                    tdsBottom = this.table.querySelectorAll(`[data-y-index=\"${dataYIndexStart + this.itemsPerHeader}\"]`);\n                } else {\n                    for(let i = dataYIndexStart + 1; i < this.table.rows.length - 1; i++) {\n                        let tdsRow = this.table.querySelectorAll(`[data-y-index=\"${i}\"]`);\n                        tdsRow = [...tdsRow];\n                        tdsBetween = tdsBetween.concat(tdsRow);\n                    }\n\n                    tdsBottom = this.table.querySelectorAll('tr:last-child td');\n                }\n\n                tdsBetween.map(td => {\n                    td.style.borderTopWidth = '0px';\n                    td.style.borderBottomWidth = '0px';\n                })\n\n                tdsBottom = [...tdsBottom];\n                tdsBottom.map((td) => {\n                    td.style.borderTopWidth = '0px';\n                });\n\n                if (this.itemsPerHeader) {\n                    rowsLength -= this.itemsPerHeader + 1;\n                    dataYIndexStart += this.itemsPerHeader + 1;\n                } else {\n                    rowsLength = 0;\n                }\n            }\n\n            tableDirectives.setDirective(['innerBorders', 'active'], 'column');\n        } else if (type == 'all') {\n            tableDirectives.setDirective(['innerBorders', 'active'], 'all');\n        }\n    }\n\n    this.innerBordersSet = function (value) {\n        let tds = this.table.getElementsByTagName('td');\n        tds = [...tds];\n        tds.map(td => {\n            td.style.borderWidth = value + 'px';\n        });\n\n        tableDirectives.setDirective(['innerBorders', 'borderWidth'], value);\n        tableDirectives.setDirective(['innerBorders', 'active'], 'all');\n    }\n\n    this.spaceBorderSpacingExchange = function (typeNumber) {\n        if(this.table.style.borderSpacing) {\n            if((typeNumber === 2 && !tableDirectives.getDirective(['innerBorders', 'borderSpacing', 'exchangeNum'])) ||\n                (typeof tableDirectives.getDirective(['innerBorders', 'borderSpacing', 'exchangeNum']) === 'number' &&\n                    tableDirectives.getDirective(['innerBorders', 'borderSpacing', 'exchangeNum']) !== typeNumber)){\n                this.table.style.borderSpacing = this.table.style.borderSpacing.split(' ').reverse().join(' ');\n                tableDirectives.setDirective(['innerBorders', 'borderSpacing', 'exchangeNum'], typeNumber);\n            }\n        }\n    }\n\n    this.rowBgColorReplaceToCellBgColor = function (color) {\n        let borderRadiusVal = tableDirectives.getDirective(['innerBorders', 'borderRadiuses', tableDirectives.getDirective(['innerBorders', 'active'])]);\n        let type;\n        if(borderRadiusVal > 0) {\n            type = true;\n        } else {\n            type = false;\n        }\n        // if(type && this.table.dataset.rowsBgColorSetToCells && !color) {\n        //     return;\n        // } else if(type) {\n        //     this.table.dataset.rowsBgColorSetToCells = '1';\n        // } else if(this.table.dataset.rowsBgColorSetToCells){\n        //     delete this.table.dataset.rowsBgColorSetToCells;\n        // } else {\n        //     return;\n        // }\n        let trs = this.table.querySelectorAll('tr');\n\n        for (let i = 0; i < trs.length; i++) {\n            let tr = trs[i];\n            if(!tr) continue;\n            // @deprecated\n            // let tds = tr.querySelectorAll('td');\n\n            let rowBgColor;\n            if(!tr.dataset.wptbBgColor) {\n                let trStyles = window.getComputedStyle(tr, null);\n                rowBgColor = trStyles.getPropertyValue('background-color');\n                // @deprecated in favor of background menu\n                // tr.dataset.wptbBgColor = rowBgColor;\n            } else {\n                rowBgColor = tr.dataset.wptbBgColor;\n            }\n            if(type === true) {\n                tr.style.backgroundColor = '#ffffff00';\n            } else {\n                tr.style.backgroundColor = tr.dataset.wptbBgColor ? tr.dataset.wptbBgColor : null;\n            }\n\n            // @deprecated\n            // for(let j = 0; j < tds.length; j++) {\n            //     let td = tds[j];\n            //     if(type === true) {\n            //         if(!td.dataset.wptbOwnBgColor) {\n            //             td.style.backgroundColor = rowBgColor;\n            //             td.dataset.wptbBgColorFromRow = rowBgColor;\n            //         }\n            //     } else {\n            //         if(!td.dataset.wptbOwnBgColor) {\n            //             td.style.backgroundColor = null;\n            //             delete td.dataset.wptbBgColorFromRow;\n            //         }\n            //     }\n            // }\n        }\n    }\n\n    this.changeRowBgColor = function (tblRow, selector) {\n        const bgColor = selector.dataset.wptbRowBgColor;\n        const orgColor = tblRow.getAttribute('org-bg-color');\n\n        if (bgColor) {\n            // @deprecated in favor of background menu\n            // tblRow.dataset.wptbBgColor = bgColor;\n\n            if (orgColor) tblRow.setAttribute('org-bg-color', bgColor);\n            else tblRow.style.backgroundColor = bgColor;\n        }\n    }\n    \n    this.changeColumnBgColor = function (selector) {\n        const index = parseInt(selector.dataset.xIndex) + 1;\n        const bgColor = selector.dataset.wptbColumnBgColor;\n        const trs = this.table.querySelectorAll('tr');\n\n        trs.forEach(tr => {\n            let td = tr.querySelector(`td:nth-child(${index})`);\n            \n            if (!td.dataset.wptbOwnBgColor) td.style.backgroundColor = bgColor;\n        });\n    }\n}\n","var WPTB_TableDirectives = function (table) {\n    this.table = table;\n    const tableDirectivesDataKey = 'wptbTableDirectives';\n\n    this.getDirectives = function () {\n        const encodedTableDirectives = this.table.dataset[tableDirectivesDataKey];\n        if (encodedTableDirectives === undefined) {\n            return false;\n        } else {\n            return JSON.parse(atob(encodedTableDirectives));\n        }\n    }\n\n    this.saveDirectives = function () {\n        if(!this.tableDirectives) return;\n        const encodedTableDirectives = btoa(JSON.stringify(this.tableDirectives));\n        this.table.dataset[tableDirectivesDataKey] = encodedTableDirectives;\n    }\n\n    this.getDirective = function (way) {\n        this.tableDirectives = this.getDirectives();\n        if(!this.tableDirectives) this.tableDirectives = {};\n        let field = this.tableDirectives;\n        let value;\n        for(let i = 0; i < way.length; i++) {\n            if(!field.hasOwnProperty(way[i])) {\n                value = false;\n                break;\n            } else {\n                if(i === way.length - 1) {\n                    value = field[way[i]];\n                    break;\n                }\n                field = field[way[i]];\n            }\n        }\n\n        return value;\n    }\n\n    this.setDirective = function (way, value) {\n        this.tableDirectives = this.getDirectives();\n        if(!this.tableDirectives) this.tableDirectives = {};\n        let field = this.tableDirectives;\n        for(let i = 0; i < way.length; i++) {\n\n            if(i === way.length - 1) {\n                field[way[i]] = value;\n                this.saveDirectives();\n                break;\n            }\n            if(!field.hasOwnProperty(way[i])) {\n                field[way[i]] = {};\n            }\n\n            field = field[way[i]];\n        }\n    }\n\n    this.tableDirectives = this.getDirectives();\n}\n"]}